'From Pharo10.0.0 of 15 March 2023 [Build information: Pharo-10.0.0+build.538.sha.179ef655ae2b150009a860b127aa3605366659ca (64 Bit)] on 25 February 2024 at 11:55:44.371 pm'!Object subclass: #Boggle	instanceVariableNames: ''	classVariableNames: ''	package: 'CPS506'!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!Boggle class	instanceVariableNames: 'dict'!!Boggle class methodsFor: 'as yet unclassified' stamp: 'DerekDao 2/25/2024 23:51'!search: board for: words	| pointBoard tmpArr st row col found marked |		row := (board at: 1) size.	col := board size.		"make a board filled with just coordinate points"	pointBoard := Array new: col.		1 to: col do: [:i | 		tmpArr := Array new: row.				1 to: row do: [:j |			tmpArr at: j put: i@j.			].			pointBoard at: i put: tmpArr.				]. 	"point board is finished here"		st := words asSet.					"make sure there is no duplicate words"	dict := Dictionary new. "for adding words with their points"		"loop through each word provided given by the word list"	st do: [:each |  			marked := OrderedCollection new. "visited variable"						each size > (row*col) ifFalse:[				self board: board pointBoard: pointBoard word:each row:row col:col visit: marked]		].		^dict													! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DerekDao 2/25/2024 23:53'!b: b p:p w: w r: r c: c len: length i: i j: j visit: visited	| bool |	(i < 1 or: i > r) ifTrue: [^false]. "out of bounds"	(j < 1 or: j > c) ifTrue: [^false].	(length > w size) ifTrue: [^false].	((b at: i) at: j) == (w at: length) ifFalse: [^false]. "characters do not match"	(visited includes: ((p at: i) at: j)) ifTrue: [^false]. "if already visited"		"characters matches because it passes the base cases"	"add point to accumulator, visited, variable that is a list of all the points visited so far"	visited add: ((p at: i) at: j).	length == (w size) ifTrue: [dict add: w -> visited asArray].		bool:= (self b: b p: p w: w r: r c: c len: (length + 1) i: (i-1) j: j visit:visited) "↓"    or: [(self b: b p: p w: w r: r c: c len: (length + 1) i: (i+1) j: j visit:visited) "↑"	 or: [(self b: b p: p w: w r: r c: c len: (length + 1) i: i j: (j-1) visit:visited) "←"	 or: [(self b: b p: p w: w r: r c: c len: (length + 1) i: i j: (j+1) visit:visited) "→"	 or: [(self b: b p: p w: w r: r c: c len: (length + 1) i: (i-1) j: (j+1) visit:visited) "↗"	 or: [(self b: b p: p w: w r: r c: c len: (length + 1) i: (i-1) j: (j-1) visit:visited) "↖"	 or: [(self b: b p: p w: w r: r c: c len: (length + 1) i: (i+1) j: (j-1) visit:visited) "↙"	 or: [(self b: b p: p w: w r: r c: c len: (length + 1) i: (i+1) j: (j+1) visit:visited) "↘"	]]]]]]].		visited removeLast.		"remove the last element of the visited variable"	^bool	! !!Boggle class methodsFor: 'as yet unclassified' stamp: 'DerekDao 2/25/2024 23:26'!board: b pointBoard: p word: w row: r col: c visit: visited	| exist |	1 to: r do: [ :i |		1 to: c do:[ :j |						"check if board and word character matches"			((b at: i) at: j) == (w at: 1) ifTrue: [				exist := self b:b p:p w:w r:r c:c len: 1 i:i j:j visit: visited.				exist 						ifTrue: [^true]]						ifFalse: [visited do: [:each | visited removeLast]].			]			].	 ^false.! !